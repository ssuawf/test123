#include "arch/arch.h"
#include "memory_manager/memory_manager.h"
#include "memory_manager/heap_manager.h"
#include "structures/virtual_address.h"
#include <ia32-doc/ia32.hpp>
#include <cstdint>

#include "crt/crt.h"
#include "interrupts/interrupts.h"
#include "slat/slat.h"
#include "slat/cr3/cr3.h"
#include "slat/violation/violation.h"

#include "dma/dma_handler.h"
#include "network/network.h"

#ifndef _INTELMACHINE
#include <intrin.h>
#endif

// ============================================================================
// hyper-reV: Software DMA via Hyper-V Parasitic Hypervisor
// ============================================================================
//
// []
//  HV  " "  :
//   PC (PCILeech/MemProcFS) LAN NIC EPT hook  dma::process()
//    EPT Guest PA R/W    NIC TX   PC
//
// [] UEFI boot, Hyper-V , EPT hook, SLAT violation, NMI,  
//
// [VMEXIT ]
//   SLAT violation  EPT R/W/X 
//   NMI  TLB flush 
//     Hyper-V   
// ============================================================================

typedef std::uint64_t(*vmexit_handler_t)(
    std::uint64_t a1, std::uint64_t a2,
    std::uint64_t a3, std::uint64_t a4);

namespace
{
    std::uint8_t* original_vmexit_handler = nullptr;
    std::uint64_t uefi_boot_physical_base_address = 0;
    std::uint64_t uefi_boot_image_size = 0;
}

void clean_up_uefi_boot_image()
{
    const auto mapped_uefi_boot_base = static_cast<std::uint8_t*>(
        memory_manager::map_host_physical(uefi_boot_physical_base_address));

    crt::set_memory(mapped_uefi_boot_base, 0, uefi_boot_image_size);
}

void process_first_vmexit()
{
    static std::uint8_t is_first_vmexit = 1;

    if (is_first_vmexit == 1)
    {
        slat::process_first_vmexit();
        interrupts::set_up();
        clean_up_uefi_boot_image();

        // DMA   
        dma::set_up();

        //    (Phase 3: NIC EPT hook )
        network::set_up();

        is_first_vmexit = 0;
    }

    //   : Guest OS/AC HV   
    static std::uint8_t has_hidden_heap_pages = 0;
    static std::uint64_t vmexit_count = 0;

    if (has_hidden_heap_pages == 0 && 10000 <= ++vmexit_count)
    {
        has_hidden_heap_pages = slat::hide_heap_pages(slat::hyperv_cr3());
    }
}

std::uint64_t do_vmexit_premature_return()
{
#ifdef _INTELMACHINE
    return 0;
#else
    return __readgsqword(0);
#endif
}

// ============================================================================
// VMEXIT 
// ============================================================================
// CPUID   - Guest   
// DMA  NIC EPT hook   (network )
// ============================================================================
std::uint64_t vmexit_handler_detour(
    const std::uint64_t a1, const std::uint64_t a2,
    const std::uint64_t a3, const std::uint64_t a4)
{
    process_first_vmexit();

    const std::uint64_t exit_reason = arch::get_vmexit_reason();

    // SLAT violation: EPT hook  R/W  X 
    if (arch::is_slat_violation(exit_reason) == 1
        && slat::violation::process() == 1)
    {
        return do_vmexit_premature_return();
    }

    // NIC RX ring   DMA    TX  
    // :  VMEXIT .  POLL_INTERVAL  .
    //       SLAT violation  (EPT   )
    //       NMI  (NMI Hyper-V )
    network::process_pending();

    // NMI:  TLB flush 
    if (arch::is_non_maskable_interrupt_exit(exit_reason) == 1)
    {
        interrupts::process_nmi();
    }

    // : Hyper-V  
    return reinterpret_cast<vmexit_handler_t>(
        original_vmexit_handler)(a1, a2, a3, a4);
}

// ============================================================================
//   (UEFI boot  HV attachment   )
// ============================================================================
void entry_point(
    std::uint8_t** const vmexit_handler_detour_out,
    std::uint8_t* const original_vmexit_handler_routine,
    const std::uint64_t heap_physical_base,
    const std::uint64_t heap_physical_usable_base,
    const std::uint64_t heap_total_size,
    const std::uint64_t _uefi_boot_physical_base_address,
    const std::uint32_t _uefi_boot_image_size,
#ifdef _INTELMACHINE
    const std::uint64_t reserved_one)
{
    (void)reserved_one;
#else
    const std::uint8_t* const get_vmcb_gadget)
{
    arch::parse_vmcb_gadget(get_vmcb_gadget);
#endif

    original_vmexit_handler = original_vmexit_handler_routine;
    uefi_boot_physical_base_address = _uefi_boot_physical_base_address;
    uefi_boot_image_size = _uefi_boot_image_size;

    heap_manager::initial_physical_base = heap_physical_base;
    heap_manager::initial_size = heap_total_size;

    *vmexit_handler_detour_out = reinterpret_cast<std::uint8_t*>(
        vmexit_handler_detour);

    const std::uint64_t heap_physical_end = heap_physical_base + heap_total_size;
    const std::uint64_t heap_usable_size = heap_physical_end
                                         - heap_physical_usable_base;

    void* const mapped_heap_usable_base = memory_manager::map_host_physical(
        heap_physical_usable_base);

    heap_manager::set_up(mapped_heap_usable_base, heap_usable_size);

    slat::set_up();
}
